/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mkdg;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import static java.awt.image.ImageObserver.HEIGHT;
import javax.swing.JButton;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.w3c.dom.css.Rect;

/**
 *
 * @author daroslav
 */
public class TransformationFrame extends javax.swing.JFrame implements ChangeListener, ActionListener {

    
    private Method method;
    private FastRGB rgbModel;
    private int[][] structuralElement;
    private int[][] processedImage;
    private int width;
    private int height;
    
    private JSlider thresholdSlider;
    private JButton processButton;
    private TransformationCanvas originalCanvas;
    private TransformationCanvas afterProcessCanvas;
    
    /**
     * Creates new form TransformationFrame
     */
    public TransformationFrame(FastRGB rgbModel, Method method, int[][] structuralElement, int width, int height) {
        this.rgbModel = rgbModel;
        this.method = method;
        this.structuralElement = structuralElement;
        this.width = width;
        this.height = height;
        
        initComponents();
        showBinaryImage();
        initAditionalElements();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        binaryImagePanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        binaryImagePanel.setBorder(new javax.swing.border.MatteBorder(null));

        javax.swing.GroupLayout binaryImagePanelLayout = new javax.swing.GroupLayout(binaryImagePanel);
        binaryImagePanel.setLayout(binaryImagePanelLayout);
        binaryImagePanelLayout.setHorizontalGroup(
            binaryImagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 601, Short.MAX_VALUE)
        );
        binaryImagePanelLayout.setVerticalGroup(
            binaryImagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 426, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(binaryImagePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(binaryImagePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void showBinaryImage() {
        originalCanvas = new TransformationCanvas(rgbModel);
        this.setBounds(0,0, width*originalCanvas.getTileSize() + 10, this.getHeight());
        this.invalidate();
        binaryImagePanel.setBounds((this.getWidth() - width*originalCanvas.getTileSize() + 10)/2, 0, width*originalCanvas.getTileSize() + 10, height*originalCanvas.getTileSize());
        binaryImagePanel.invalidate();
        
        originalCanvas.setBounds((binaryImagePanel.getWidth() - width*originalCanvas.getTileSize())/2, 
                         0, 
                         width*originalCanvas.getTileSize(),
                         height*originalCanvas.getTileSize());
        
        binaryImagePanel.add(originalCanvas);
        binaryImagePanel.invalidate();
        originalCanvas.repaint();     
    }
    
    private void showImageAfterProcess(int[][] binaryModelAfterProcess) {
           
        if(afterProcessCanvas != null) {
            binaryImagePanel.remove(afterProcessCanvas);
        }
          
        afterProcessCanvas = new TransformationCanvas(binaryModelAfterProcess);
        binaryImagePanel.setBounds(0,0, width*originalCanvas.getTileSize() * 2 + 20, height*originalCanvas.getTileSize());
        
        originalCanvas.setBounds(5, 
                                 0, 
                                 width*originalCanvas.getTileSize(),
                                 height*originalCanvas.getTileSize());
        
        afterProcessCanvas.setBounds(originalCanvas.getWidth() + 10, 
                                     0, 
                                     width*originalCanvas.getTileSize(),
                                     height*originalCanvas.getTileSize());
        
        binaryImagePanel.add(afterProcessCanvas);
        binaryImagePanel.invalidate();
        afterProcessCanvas.repaint();
        
        this.setBounds(0,0, width*originalCanvas.getTileSize() * 2 + 20, this.getHeight());
        this.thresholdSlider.invalidate();
        this.processButton.invalidate();
    }
    
    private void initAditionalElements() {
        thresholdSlider = new JSlider();
        thresholdSlider.setBounds(20, binaryImagePanel.getHeight() + 10, width*originalCanvas.getTileSize() + 10 - 40, 25);
        thresholdSlider.setVisible(true);
        binaryImagePanel.add(thresholdSlider);
        binaryImagePanel.invalidate();
        thresholdSlider.setMinimum(0);
        thresholdSlider.setMaximum(100);
        thresholdSlider.setValue(20);
        thresholdSlider.setMajorTickSpacing(10);
        thresholdSlider.setPaintTicks(true);
        thresholdSlider.addChangeListener(this);
        
        processButton = new JButton();
        processButton.setBounds(20, thresholdSlider.getY() + 35, width*originalCanvas.getTileSize() + 10 - 40, 25);
        if(method == Method.Dilation) {
            processButton.setText("Dylatacja");
        } else {
            processButton.setText("Erozja");
        }
        binaryImagePanel.add(processButton);
        processButton.addActionListener(this);
        
    }

    @Override
    public void stateChanged(ChangeEvent e) {
        Object source = e.getSource();
        if(source instanceof JSlider) {
            JSlider theJSlider = (JSlider) source;
            //if (!theJSlider.getValueIsAdjusting()) {
                System.out.println("Slider changed: " + theJSlider.getValue());
                rgbModel.setThreshold(theJSlider.getValue());
                originalCanvas.updateBinaryImage();
            //}
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        if(source instanceof JButton) {
            if(method == Method.Dilation) {
                if(processedImage == null) {
                    processedImage = dilate(rgbModel.getImageAsBinaryArray());
                } else {
                    processedImage = dilate(processedImage);
                }
                showImageAfterProcess(processedImage);
            } else {
                if(processedImage == null) {
                    processedImage = erode(rgbModel.getImageAsBinaryArray());
                } else {
                    processedImage = erode(processedImage);
                }
                showImageAfterProcess(processedImage);
            }
        }
    }
 
    int[][] dilate(int[][] image){
        int[][] imagecopy = new int[image.length][image[0].length];
        for (int i=0; i<image.length; i++){
            for (int j=0; j<image[i].length; j++){
                if (image[i][j] == 1){
                    imagecopy[i][j] = 1;
                    if (structuralElement[0][1] == 1 && i>0) imagecopy[i-1][j] = 1;
                    if (structuralElement[1][0] == 1 && j>0) imagecopy[i][j-1] = 1;
                    if (structuralElement[2][1] == 1 && i+1<image.length) imagecopy[i+1][j] = 1;
                    if (structuralElement[1][2] == 1 && j+1<image[i].length) imagecopy[i][j+1] = 1;
                    
                    if (structuralElement[0][0] == 1 && i>0 && j>0) imagecopy[i-1][j-1] = 1;
                    if (structuralElement[0][2] == 1 && i>0 && j+1<image[i].length) imagecopy[i-1][j+1] = 1;
                    if (structuralElement[2][0] == 1 && i+1<image.length && j>0) imagecopy[i+1][j-1] = 1;
                    if (structuralElement[2][2] == 1 && i+1<image.length && j+1<image[i].length) imagecopy[i+1][j+1] = 1;
                }
            }
        }
        return imagecopy;
    }
    
    int[][] erode(int[][] image){
        int[][] imagecopy = new int[image.length][image[0].length];
        for (int i = 0; i < imagecopy.length; i++) {
            for (int j = 0; j < imagecopy[0].length; j++) {
                imagecopy[i][j] = 1;
            }
        }
        for (int i=0; i<image.length; i++){
            for (int j=0; j<image[i].length; j++){
                if (image[i][j] == 0){
                    imagecopy[i][j] = 0;
                    if (structuralElement[0][1] == 1 && i>0) imagecopy[i-1][j] = 0;
                    if (structuralElement[1][0] == 1 && j>0) imagecopy[i][j-1] = 0;
                    if (structuralElement[2][1] == 1 && i+1<image.length) imagecopy[i+1][j] = 0;
                    if (structuralElement[1][2] == 1 && j+1<image[i].length) imagecopy[i][j+1] = 0;
                    
                    if (structuralElement[0][0] == 1 && i>0 && j>0) imagecopy[i-1][j-1] = 0;
                    if (structuralElement[0][2] == 1 && i>0 && j+1<image[i].length) imagecopy[i-1][j+1] = 0;
                    if (structuralElement[2][0] == 1 && i+1<image.length && j>0) imagecopy[i+1][j-1] = 0;
                    if (structuralElement[2][2] == 1 && i+1<image.length && j+1<image[i].length) imagecopy[i+1][j+1] = 0;
                }
            }
        }
        return imagecopy;
    }
    
    public enum Method {
        Erosion, Dilation
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel binaryImagePanel;
    // End of variables declaration//GEN-END:variables
}
