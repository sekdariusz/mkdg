/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mkdg;

import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import static java.awt.image.ImageObserver.HEIGHT;
import java.util.Properties;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.w3c.dom.css.Rect;

/**
 *
 * @author daroslav
 */
public class TransformationFrame extends javax.swing.JFrame implements ChangeListener, ActionListener {

    
    private FastRGB rgbModel;
    private int[][] structuralElement;
    private int[][] processedImage;
    private int width;
    private int height;
    
    private JSlider thresholdSlider;
    private JButton dilationButton;
    private JButton erosionButton;
    private TransformationCanvas originalCanvas;
    private TransformationCanvas afterProcessCanvas;
    private GridBagConstraints c;
    
    /**
     * Creates new form TransformationFrame
     */
    public TransformationFrame(FastRGB rgbModel, int[][] structuralElement, int width, int height) {
        this.rgbModel = rgbModel;
        this.structuralElement = structuralElement;
        this.width = width;
        this.height = height;
        
        System.out.println("w: " + width + " h: " + height);
        
        initComponents();
        
        binaryImagePanel.setLayout(new GridBagLayout());
        c = new GridBagConstraints();
        c.insets = new Insets(6,6,6,6);

        showBinaryImage();
        initAditionalElements();
      
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        binaryImagePanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        binaryImagePanel.setBorder(new javax.swing.border.MatteBorder(null));

        javax.swing.GroupLayout binaryImagePanelLayout = new javax.swing.GroupLayout(binaryImagePanel);
        binaryImagePanel.setLayout(binaryImagePanelLayout);
        binaryImagePanelLayout.setHorizontalGroup(
            binaryImagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 601, Short.MAX_VALUE)
        );
        binaryImagePanelLayout.setVerticalGroup(
            binaryImagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 426, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(binaryImagePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(binaryImagePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void showBinaryImage() {
        originalCanvas = new TransformationCanvas(rgbModel);
        this.setBounds(0,0, width*originalCanvas.getTileSize() + 10, this.getHeight());
        this.invalidate();
        binaryImagePanel.setBounds((this.getWidth() - width*originalCanvas.getTileSize() + 10)/2, 0, width*originalCanvas.getTileSize() + 10, height*originalCanvas.getTileSize());
        binaryImagePanel.invalidate();
        
        originalCanvas.setBounds((binaryImagePanel.getWidth() - width*originalCanvas.getTileSize())/2, 
                         0, 
                         width*originalCanvas.getTileSize(),
                         height*originalCanvas.getTileSize());
        
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        
        binaryImagePanel.add(originalCanvas, c);
        binaryImagePanel.invalidate();
        originalCanvas.repaint();     
    }
    
    private void showImageAfterProcess(int[][] binaryModelAfterProcess) {
        
        //this.setPreferredSize(new Dimension((int)(width*originalCanvas.getTileSize() * 2 + 20), this.getHeight()));

        if(afterProcessCanvas != null) {
            binaryImagePanel.remove(afterProcessCanvas);
        }
          
        afterProcessCanvas = new TransformationCanvas(binaryModelAfterProcess);
        binaryImagePanel.setBounds(0,0, width*originalCanvas.getTileSize() * 2 + 20, height*originalCanvas.getTileSize());
        
        originalCanvas.setBounds(5, 
                                 0, 
                                 width*originalCanvas.getTileSize(),
                                 height*originalCanvas.getTileSize());
        
        afterProcessCanvas.setBounds(originalCanvas.getWidth() + 10, 
                                     0, 
                                     width*originalCanvas.getTileSize(),
                                     height*originalCanvas.getTileSize());
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 1;
        c.gridy = 0;
        binaryImagePanel.add(afterProcessCanvas, c);       
        this.pack();
    }
    
    private void initAditionalElements() {
        thresholdSlider = new JSlider();
        thresholdSlider.setBounds(20, binaryImagePanel.getHeight() + 10, width*originalCanvas.getTileSize() + 10 - 40, 25);
        thresholdSlider.setVisible(true);
        
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 1;
        binaryImagePanel.add(thresholdSlider, c);
        
        binaryImagePanel.invalidate();
        thresholdSlider.setMinimum(0);
        thresholdSlider.setMaximum(100);
        thresholdSlider.setValue(20);
        thresholdSlider.setMajorTickSpacing(10);
        thresholdSlider.setPaintTicks(true);
        thresholdSlider.addChangeListener(this);
        
        dilationButton = new JButton();
        dilationButton.setBounds(20, thresholdSlider.getX() + thresholdSlider.getWidth() + 10, width*originalCanvas.getTileSize() + 10 - 40, 25);
        dilationButton.setText("Dylatacja"); 
        
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 2;
        binaryImagePanel.add(dilationButton, c);
        
        dilationButton.addActionListener(this);
        
        erosionButton = new JButton();
        erosionButton.setBounds(20, dilationButton.getX() + dilationButton.getWidth() + 10, width*originalCanvas.getTileSize() + 10 - 40, 25);
        erosionButton.setText("Erozja");
       
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 3;
        binaryImagePanel.add(erosionButton, c);
        
        erosionButton.addActionListener(this);
        
        this.pack();
    }

    @Override
    public void stateChanged(ChangeEvent e) {
        Object source = e.getSource();
        if(source instanceof JSlider) {
            JSlider theJSlider = (JSlider) source;
            //if (!theJSlider.getValueIsAdjusting()) {
                System.out.println("Slider changed: " + theJSlider.getValue());
                rgbModel.setThreshold(theJSlider.getValue());
                originalCanvas.updateBinaryImage();
                processedImage = null;
            //}
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        if(source == dilationButton) {
            if(processedImage == null) {
                processedImage = dilate(rgbModel.getImageAsBinaryArray());
            } else {
                processedImage = dilate(processedImage);
            }
            showImageAfterProcess(processedImage);
        } else {
            if(processedImage == null) {
                processedImage = erode(rgbModel.getImageAsBinaryArray());
            } else {
                processedImage = erode(processedImage);
            }
            showImageAfterProcess(processedImage);
        }       
    }
 
    int[][] dilate(int[][] image){
        int[][] imagecopy = new int[image.length][image[0].length];
        
        for (int i = 0; i < imagecopy.length; i++) {
            for (int j = 0; j < imagecopy[0].length; j++) {
                imagecopy[i][j] = image[i][j];
            }
        }
        
        for (int i=0; i<image.length; i++){
            for (int j=0; j<image[i].length; j++){
                if (image[i][j] == 1){
                    if (structuralElement[1][1] == 1) imagecopy[i][j] = 1;
                    
                    if (structuralElement[0][1] == 1 && i>0) imagecopy[i-1][j] = 1;
                    if (structuralElement[1][0] == 1 && j>0) imagecopy[i][j-1] = 1;
                    if (structuralElement[2][1] == 1 && i+1<image.length) imagecopy[i+1][j] = 1;
                    if (structuralElement[1][2] == 1 && j+1<image[i].length) imagecopy[i][j+1] = 1;
                    
                    if (structuralElement[0][0] == 1 && i>0 && j>0) imagecopy[i-1][j-1] = 1;
                    if (structuralElement[0][2] == 1 && i>0 && j+1<image[i].length) imagecopy[i-1][j+1] = 1;
                    if (structuralElement[2][0] == 1 && i+1<image.length && j>0) imagecopy[i+1][j-1] = 1;
                    if (structuralElement[2][2] == 1 && i+1<image.length && j+1<image[i].length) imagecopy[i+1][j+1] = 1;
                }
            }
        }
        return imagecopy;
    }
    
    int[][] erode(int[][] image){
        int[][] imagecopy = new int[image.length][image[0].length];
        for (int i = 0; i < imagecopy.length; i++) {
            for (int j = 0; j < imagecopy[0].length; j++) {
                imagecopy[i][j] = image[i][j];
            }
        }
        for (int i=0; i<image.length; i++){
            for (int j=0; j<image[i].length; j++){
                if (image[i][j] == 0){
                    if (structuralElement[1][1] == 1) imagecopy[i][j] = 0;
                    
                    if (structuralElement[0][1] == 1 && i>0) imagecopy[i-1][j] = 0;
                    if (structuralElement[1][0] == 1 && j>0) imagecopy[i][j-1] = 0;
                    if (structuralElement[2][1] == 1 && i+1<image.length) imagecopy[i+1][j] = 0;
                    if (structuralElement[1][2] == 1 && j+1<image[i].length) imagecopy[i][j+1] = 0;
                    
                    if (structuralElement[0][0] == 1 && i>0 && j>0) imagecopy[i-1][j-1] = 0;
                    if (structuralElement[0][2] == 1 && i>0 && j+1<image[i].length) imagecopy[i-1][j+1] = 0;
                    if (structuralElement[2][0] == 1 && i+1<image.length && j>0) imagecopy[i+1][j-1] = 0;
                    if (structuralElement[2][2] == 1 && i+1<image.length && j+1<image[i].length) imagecopy[i+1][j+1] = 0;
                }
            }
        }
        return imagecopy;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel binaryImagePanel;
    // End of variables declaration//GEN-END:variables
}
